# 类视图

之前我们接触的视图都是函数，所以一般简称视图函数。其实视图也可以基于类来实现，类视图的好处是支持继承，但是类视图不能跟函数视图一样，写完类视图还需要通过`app.add_url_rule(url_rule,view_func)`来进行注册。以下将对两种类视图进行讲解：

## 标准类视图：

标准类视图是继承自`flask.views.View`，并且在子类中必须实现`dispatch_request`方法，这个方法类似于视图函数，也要返回一个基于`Response`或者其子类的对象。以下将用一个例子进行讲解：

```python
from flask.views import View
class PersonalView(View):
    def dispatch_request(self):
        return "kangbazi"
# 类视图通过add_url_rule方法和url做映射
app.add_url_rule('/users/',view_func=PersonalView.as_view('personalview'))
```

### 基于调度方法的视图：

`Flask`还为我们提供了另外一种类视图`flask.views.MethodView`，对每个HTTP方法执行不同的函数（映射到对应方法的小写的同名方法上），以下将用一个例子来进行讲解：

```python
    class LoginView(views.MethodView):
        # 当客户端通过get方法进行访问的时候执行的函数
        def get(self):
            return render_template("login.html")

        # 当客户端通过post方法进行访问的时候执行的函数
        def post(self):
            email = request.form.get("email")
            password = request.form.get("password")
            if email == 'xx@qq.com' and password == '111111':
                return "登录成功！"
            else:
                return "用户名或密码错误！"

    # 通过add_url_rule添加类视图和url的映射，并且在as_view方法中指定该url的名称，方便url_for函数调用

    app.add_url_rule('/myuser/',view_func=LoginView.as_view('loginview'))
```

用类视图的一个缺陷就是比较难用装饰器来装饰，比如有时候需要做权限验证的时候，比如看以下例子：

```python
from flask import session
def login_required(func):
    def wrapper(*args,**kwargs):
        if not session.get("user_id"):
            return 'auth failure'
        return func(*args,**kwargs)
    return wrapper
```

装饰器写完后，可以在类视图中定义一个属性叫做`decorators`，然后存储装饰器。以后每次调用这个类视图的时候，就会执行这个装饰器。示例代码如下：

```python
class UserView(views.MethodView):
    decorators = [user_required]
    ...
```



## flask-script  

> 通过命令行来操作flask    原本我们是通过 python 实例文件执行 但是 所有的程序应该有一个入口文件   
>
> 通过入口文件 启动实例    
>
> 之前我们 实例中  开启debug  代码自动加载  自定义端口号   现在这些 我们可以直接用命令完成  

```
pip install flask-script    #flask 所有的扩展都是这么安装的 
```



1.新建一个 manage.py 作为程序的入口文件  

2.在入口文件中 导入  from flask_script import Manager

3.到入flask实例    from app import app 我想通过 入口文件启动实例  需要把实例引入进来  

4.实例化manager  将app 传入 完成绑定  



5.进入指定的虚拟环境  然后进入项目所在的目录    -- 命令行中    

6.python manage.py runserver  -d  -r -p 5001 --threaded    -h 0.0.0.0 

-d 开启debug模式  

-r 如果代码发生变化 自动重新加载  

-p 指定端口号 

--threaded 开启多线程模式   

-h 允许所有的ip都可以访问  

