1、Ajax是异步的JavaScript和xml,优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容，
   它不需要任何浏览插件，但需要用户允许JavaScript在浏览器上执行
   Ajax是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量的数据交换，ajax可以使网页实现异步更新。
   这意味着可以不重新加载整个网页的情况下，对网页的某部分进行更新

2、ps -ef | grep nginx、deactivate
3、面试基本算法，404，40之类的区别、mysql、redis、mogodb数据库的区别和原理、进程线程协程、
4、MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的
5、Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
6、MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。
而MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。

此外，MySQL内部有多种数据库引擎，最常用的引擎是支持数据库事务的InnoDB。
7、稍微总结 Django 和 Flask 的特点：
	Django 提供了一系列的比较成熟的解决方案，鼓励用户使用这些现成的解决方案来快速开发系统。这些解决方案看似独立，
        其实在不同程度上互相配合，Django 这些 All in one 的理念，尤其擅长于开发电商系统。
        Flask 是一个微框架，其提供了比较完善的 Web 服务器所需的基本功能，同时允许且建议用户自由选择扩展的技术。
        Flask 适合开发 API 服务（如有独立的权限系统，依赖的第三方组件）。
   其二者的区别包括但不限于：
	权限系统
	缓存中间件
	数据库ORM
	模板引擎
	国际化处理
8、djangop中间件：
	中间件顾名思义，是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。
        因为改变的是全局，所以需要谨慎实用，用不好会影响到性能。我们从浏览器发出一个请求 Request，得到一个响应后的内容 
        HttpResponse ，每一个请求都是先通过中间件中的 process_request 函数，这个函数返回 None 或者 HttpResponse 对象，
        如果返回前者，继续处理其它中间件，如果返回一个 HttpResponse，就处理中止，返回到网页上。中间件不用继承自任何类
       （可以继承 object ）
     中间件的用处：
	比如我们要做一个 拦截器，发现有恶意访问网站的人，就拦截他！假如我们通过一种技术，比如统计一分钟访问页面的次数，
        太多就把他的 IP 加入到黑名单 
     用法：
        我们在网站放到服务器上正式运行后，DEBUG改为了 False，这样更安全，但是有时候发生错误我们不能看到错误详情，调试不方便，
        有没有办法处理好这两个事情呢？普通访问者看到的是友好的报错信息；管理员看到的是错误详情，以便于修复 BUG；当然可以有，
        利用中间件就可以做到，个Django项目的起始执行如下：先走WSGI，然后再走中间件，注意一点，自带的中间件的顺序是不能倒置的，
        因为有可能下一个中间件要依赖于上一个中间件的数据，如果随意颠倒顺序，会报错，我们通常将自定义的中间件放到最下面
        request请求经过WSGI后，先进入中间件，依然开始先走process_request函数，然后走路由关系映射后，这里注意
	并没有直接进入视图函数，而是从头开始执行process_view()函数；然后再去执行与urls.py匹配的视图函数；
	如果视图函数没有报错，那就直接挨个反过来从最后一个中间件开始，依次将返回的实例对象(也就是我们在视图函数中
	写的 return HttpResponse()等等)传递给每个中间件的process_response函数；最后再交给客户端浏览器；
	如果执行视图函数出错，那就反过来从最后一个中间件开始，将错误信息传递给每个中间件的process_exception()函数，走完所有后，
        然后最终再走procss_response后，最终再交给客户端浏览器
	注意：视图函数的错误是由process_exception()函数处理的，从最后一个中间件开始，依次逐级提交捕捉到的异常
1. 参与运维服务API的框架的搭建、研发以及优化。
2. 参与服务监控平台的搭建、研发以及优化。
3. 参与部门内部信息流平台的研发和优化。
1、量化交易系统后端代码编写
2、完善产品架构
3、理解产品需求，配合团队工作
4、解决疑难问题
- 负责公司产品的后端开发和升级优化工作
- 参与相关产品需求讨论与产品系统架构的设计和优化 
1、负责爬虫核心技术的设计和开发；
2、设计爬取、调度和抽取算法，优化系统；
3、设计爬虫策略和防屏蔽规则，提升系统抓取的效率和质量；
4、对指定网站、系统进行数据抓取的开发工作；
5、及时解决爬虫抓取过程中出现的问题并不断维护、优化程
1、负责运维系统的开发；
2、负责与业务系统中的接口对接；
3、参与需求讨论并撰写相关技术文档。
1.负责Python软件、服务器程序、网站后台的设计和优化；
2.负责实现软件、应用程序代码，建立和完善开发文档；
3.产品发布上线时，协助完成项目调试、部署等工作；
4.持续改进产品，为公司其他部门提供技术方案评估。
1、负责线上系统的优化及维护；
2、完成项目的需求设计及开发；
3、负责开发过程中相关文档的编写；
4、保质保量完成上级安排的工作；

1、负责Python软件、服务器程序、网站后台的设计和优化；
2、参与相关产品需求讨论与产品系统架构的设计和优化 
3、理解产品需求，配合团队工作
4、负责与业务系统中的接口对接；
5、设计爬虫策略和防屏蔽规则，提升系统抓取的效率和质量；
6、对指定网站、系统进行数据抓取的开发工作
7、及时解决爬虫抓取过程中出现的问题并不断维护、优化程序
8、产品发布上线时，协助完成项目调试、部署等工作；
9、持续改进产品，为公司其他部门提供技术方案评估
10、负责实现软件、应用程序代码，建立和完善开发文档

MVC：
MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：[1] 
Model（模型）表示应用程序核心（比如数据库记录列表）。
View（视图）显示数据（数据库记录）。
Controller（控制器）处理输入（写入数据库记录）。
MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
　　通常模型对象负责在数据库中存取数据。
View（视图）是应用程序中处理数据显示的部分。
　　通常视图是依据模型数据创建的。
Controller（控制器）是应用程序中处理用户交互的部分。
　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。
MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻

藕合度指程序模块间存联系紧密程度  
内聚性则模块内部相互依赖程度
低耦合模块间关联少越独立耦合度越低
高内聚模块内容针干事情少功能越单内聚越高  
低耦合 电脑主板各种插槽连接外置各种各设备需要做要简单插进   管工模块设计模块间联系越少越

Cookie与Session的区别
cookie数据存放在客户的浏览器上，session数据放在服务器上；
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；
Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，
上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，
而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用
（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，
我发现禁掉cookie，网站的session都无法正常的访问）


MemCache的工作流程如下：先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，
就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；
每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，
失效数据首先被替换，然后再替换掉最近未使用的数据。[2] 
Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。
简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度


PhantomJS框架帮助我们像浏览器一样渲染JS处理的页面，Selenium模拟浏览器操作


uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。
要注意 WSGI / uwsgi / uWSGI 这三个概念的区分。
WSGI是一种通信协议。
uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。
而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。
uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。



Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，
事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
Nginx作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP代理服务器对外进行服务。Nginx采用C进行编写，
不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。无缓存的反向代理加速，简单的负载均衡和容错




paramiko模块提供了ssh及sft进行远程登录服务器执行命令和上传下载文件的功能


 psutil是一个跨平台库（http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，
分析和限制系统资源及进程的管理
 1、查看cpu所有信息 psutil.cpu_times()
 2、显示cpu所有逻辑信息  psutil.cpu_times(percpu=True)
 3、查看用户的cpu时间比 psutil.cpu_times().user
 4、查看cpu逻辑个数  psutil.cpu_count()
 5、查看cpu物理个数 psutil.cpu_count(logical=False)
 6、查看系统内存 mem = psutil.virtual_memory()
 7、系统总计内存 mem.total
 8、系统已经使用内存 mem.used
 9、系统空闲内存 mem.free
 10、获取swap内存信息 psutil.swap_memory()
 11、读取磁盘参数

 磁盘利用率使用psutil.disk_usage方法获取，

 磁盘IO信息包括read_count(读IO数)，write_count(写IO数)
 read_bytes(IO写字节数)，read_time(磁盘读时间)，write_time(磁盘写时间),这些IO信息用

 psutil.disk_io_counters()
 获取磁盘的完整信息

 psutil.disk_partitions()
 获取分区表的参数

 psutil.disk_usage('/')   #获取/分区的状态
 获取硬盘IO总个数

 psutil.disk_io_counters()
 获取单个分区IO个数

 psutil.disk_io_counters(perdisk=True)    #perdisk=True参数获取单个分区IO个数
 读取网络信息

 网络信息与磁盘IO信息类似,涉及到几个关键点，包括byes_sent(发送字节数),byte_recv=xxx(接受字节数),
 pack-ets_sent=xxx(发送字节数),pack-ets_recv=xxx(接收数据包数),这些网络信息用

 获取网络总IO信息

 psutil.net_io_counters()  
 输出网络每个接口信息

 psutil.net_io_counters(pernic=True)     #pernic=True
 获取当前系统用户登录信息

 psutil.users()
 获取开机时间

 psutil.boot_time() #以linux时间格式返回

 datetime.datetime.fromtimestamp(psutil.boot_time ()).strftime("%Y-%m-%d %H: %M: %S") #转换成自然时间格式

 系统进程管理
 获取当前系统的进程信息,获取当前程序的运行状态,包括进程的启动时间,查看设置CPU亲和度,内存使用率,IO信息
 socket连接,线程数等
 获取进程信息
 查看系统全部进程

 psutil.pids()
 查看单个进程

 p = psutil.Process(2423) 
 p.name()   #进程名
 p.exe()    #进程的bin路径
 p.cwd()    #进程的工作目录绝对路径
 p.status()   #进程状态
 p.create_time()  #进程创建时间
 p.uids()    #进程uid信息
 p.gids()    #进程的gid信息
 p.cpu_times()   #进程的cpu时间信息,包括user,system两个cpu信息
 p.cpu_affinity()  #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好
 p.memory_percent()  #进程内存利用率
 p.memory_info()    #进程内存rss,vms信息
 p.io_counters()    #进程的IO信息,包括读写IO数字及参数
 p.connectios()   #返回进程列表
 p.num_threads()  #进程开启的线程数
 听过psutil的Popen方法启动应用程序，可以跟踪程序的相关信息
 from subprocess import PIPE
 p = psutil.Popen(["/usr/bin/python", "-c", "print('hello')"],stdout=PIPE)
 p.name()
 p.username()


 pyecharts 是一个用于生成 Echarts 图表的类库。
 Echarts 是百度开源的一个数据可视化 JS 库。主要用于数据可视化。
 from pyecharts import Bar


 bar = Bar("我的第一个图表", "这里是副标题")

 bar.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"], [5, 20, 36, 10, 75, 90])

 bar.show_config()
bar.render()


 
 Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形













